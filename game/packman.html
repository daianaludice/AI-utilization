</button>
            </div>
        
            <canvas id="gameCanvas" width="840" height="840"></canvas>
            
            <div class="game-info">
                <div class="score">점수: <span id="scoreValue">0</span></div>
                <div class="lives">남은 목숨: <span id="livesValue">3</span></div>
                <div class="level">레벨: <span id="levelValue">1</span></div>
            </div>
        
            <div id="gameOverScreen" class="game-over-screen hidden">
                <h1>게임 오버!</h1>
                <p>최종 점수: <span id="finalScore">0</span></p>
                <button id="restartButton">다시 시작</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreValue = document.getElementById('scoreValue');
        const livesValue = document.getElementById('livesValue');
        const levelValue = document.getElementById('levelValue');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startScreen = document.querySelector('.start-screen');
        const restartButton = document.getElementById('restartButton');
        const startButton = document.getElementById('startButton');
        const guestButton = document.getElementById('guestButton');
        const finalScore = document.getElementById('finalScore');
        const nicknameInput = document.getElementById('nicknameInput');
        const scoreboardList = document.getElementById('scoreboardList');

        const TILE_SIZE = 40; 
        const GRID_WIDTH = 21;
        const GRID_HEIGHT = 21;
        const PACMAN_SPEED = 0.1;
        const GHOST_SPEED = 0.05;

        let gameMaze;
        let pacman;
        let ghosts;
        let score;
        let lives;
        let level;
        let dots;
        let isGameOver;
        let gameRunning;
        let isRespawning;
        let respawnTimer;
        let lastTimestamp;
        let intendedDx = 0;
        let intendedDy = 0;
        let nickname = '게스트';
        let scoreboard = [];

        // Maze generation using recursive backtracking with a second pass to add more paths
        function generateMaze() {
            const maze = [];
            for (let i = 0; i < GRID_HEIGHT; i++) {
                maze[i] = [];
                for (let j = 0; j < GRID_WIDTH; j++) {
                    maze[i][j] = 'W';
                }
            }
            
            const stack = [];
            const startX = 1;
            const startY = 1;
            maze[startY][startX] = ' ';
            stack.push({ x: startX, y: startY });

            while (stack.length > 0) {
                const current = stack.pop();
                const x = current.x;
                const y = current.y;
                
                const neighbors = [];
                const possibleMoves = [[0, 2], [0, -2], [2, 0], [-2, 0]];

                for (const move of possibleMoves) {
                    const nextX = x + move[0];
                    const nextY = y + move[1];

                    if (nextX > 0 && nextX < GRID_WIDTH - 1 && nextY > 0 && nextY < GRID_HEIGHT - 1 && maze[nextY][nextX] === 'W') {
                        neighbors.push({ x: nextX, y: nextY, dx: move[0], dy: move[1] });
                    }
                }

                if (neighbors.length > 0) {
                    stack.push(current);
                    const chosen = neighbors[Math.floor(Math.random() * neighbors.length)];
                    
                    maze[chosen.y][chosen.x] = ' ';
                    maze[y + chosen.dy / 2][x + chosen.dx / 2] = ' ';

                    stack.push(chosen);
                }
            }
            
            for (let y = 1; y < GRID_HEIGHT - 1; y++) {
                for (let x = 1; x < GRID_WIDTH - 1; x++) {
                    if (maze[y][x] === 'W') {
                        const horizontalConnected = maze[y][x - 1] !== 'W' && maze[y][x + 1] !== 'W';
                        const verticalConnected = maze[y - 1][x] !== 'W' && maze[y + 1][x] !== 'W';

                        if ((horizontalConnected || verticalConnected) && Math.random() < 0.15) {
                            maze[y][x] = ' ';
                        }
                    }
                }
            }
            
            return maze;
        }

        // Initialize the game (called on first start)
        function initGame() {
            score = 0;
            lives = 3;
            level = 1;
            isGameOver = false;
            gameRunning = true;
            setupLevel();
        }

        // Set up each level
        function setupLevel() {
            gameMaze = generateMaze();
            pacman = { x: 1, y: 1, dx: 0, dy: 0, radius: TILE_SIZE / 2 * 0.8, mouthOpen: false, angle: 0 };
            ghosts = [];
            dots = 0;
            isRespawning = false;
            respawnTimer = 0;
            intendedDx = 0;
            intendedDy = 0;
            
            // Generate dots and count them
            for (let y = 0; y < gameMaze.length; y++) {
                for (let x = 0; x < gameMaze[y].length; x++) {
                    if (gameMaze[y][x] === ' ') {
                        gameMaze[y][x] = '.';
                        dots++;
                    }
                }
            }

            // Set up Pacman and Ghost initial positions
            gameMaze[pacman.y][pacman.x] = ' ';
            dots--;
            
            // Find a valid, non-wall position for ghosts to spawn that is not near Pac-Man's start
            let ghostSpawnX, ghostSpawnY;
            let foundSpawnPoint = false;
            const maxAttempts = GRID_WIDTH * GRID_HEIGHT;
            let attempts = 0;

            while (!foundSpawnPoint && attempts < maxAttempts) {
                const randX = Math.floor(Math.random() * GRID_WIDTH);
                const randY = Math.floor(Math.random() * GRID_HEIGHT);

                // Check if the tile is a valid path and not too close to Pac-Man's starting point
                const isFarEnough = (Math.abs(randX - pacman.x) > 5 || Math.abs(randY - pacman.y) > 5);

                if (gameMaze[randY] && gameMaze[randY][randX] !== 'W' && isFarEnough) {
                    ghostSpawnX = randX;
                    ghostSpawnY = randY;
                    foundSpawnPoint = true;
                }
                attempts++;
            }
            // If no point is found after many attempts, fall back to a default location
            if (!foundSpawnPoint) {
                ghostSpawnX = Math.floor(GRID_WIDTH / 2);
                ghostSpawnY = Math.floor(GRID_HEIGHT / 2);
            }
            
            ghosts.push({ x: ghostSpawnX, y: ghostSpawnY, dx: 0, dy: 0, color: '#ff0000', scared: false, released: true });
            ghosts.push({ x: ghostSpawnX + 1, y: ghostSpawnY, dx: 0, dy: 0, color: '#ffb8de', scared: false, released: true });
            ghosts.push({ x: ghostSpawnX, y: ghostSpawnY + 1, dx: 0, dy: 0, color: '#00ffff', scared: false, released: true });
            ghosts.push({ x: ghostSpawnX + 1, y: ghostSpawnY + 1, dx: 0, dy: 0, color: '#ffb852', scared: false, released: true });
            
            // Clear dots from ghost spawn area
            for (let y = ghostSpawnY; y <= ghostSpawnY + 1; y++) {
                for (let x = ghostSpawnX; x <= ghostSpawnX + 1; x++) {
                     if (gameMaze[y] && gameMaze[y][x] === '.') {
                        gameMaze[y][x] = ' ';
                        dots--;
                    }
                }
            }

            updateScore();
            updateLives();
            updateLevel();
            
            gameOverScreen.classList.add('hidden');
            startScreen.classList.add('hidden');
            canvas.style.display = 'block';
        }

        // Move to the next level
        function nextLevel() {
            level++;
            setupLevel();
        }

        function drawMaze() {
            for (let y = 0; y < gameMaze.length; y++) {
                for (let x = 0; x < gameMaze[y].length; x++) {
                    const char = gameMaze[y][x];
                    const screenX = x * TILE_SIZE;
                    const screenY = y * TILE_SIZE;

                    if (char === 'W') {
                        ctx.fillStyle = '#1e1e90';
                        ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                    } else if (char === '.') {
                        ctx.fillStyle = 'yellow';
                        ctx.beginPath();
                        ctx.arc(screenX + TILE_SIZE / 2, screenY + TILE_SIZE / 2, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        function drawPacman() {
            if (isRespawning) {
                ctx.globalAlpha = Math.abs(Math.sin(Date.now() / 100));
            } else {
                ctx.globalAlpha = 1;
            }
            
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            let startAngle, endAngle;
            if (pacman.mouthOpen) {
                const mouthAngle = Math.PI / 4;
                startAngle = pacman.angle - mouthAngle;
                endAngle = pacman.angle + mouthAngle;
            } else {
                startAngle = 0;
                endAngle = Math.PI * 2;
            }
            ctx.arc(pacman.x * TILE_SIZE + TILE_SIZE / 2, pacman.y * TILE_SIZE + TILE_SIZE / 2, pacman.radius, startAngle, endAngle);
            ctx.lineTo(pacman.x * TILE_SIZE + TILE_SIZE / 2, pacman.y * TILE_SIZE + TILE_SIZE / 2);
            ctx.fill();

            ctx.globalAlpha = 1;
        }

        function drawGhosts() {
            ghosts.forEach(ghost => {
                ctx.fillStyle = ghost.scared ? '#0000ff' : ghost.color;
                ctx.beginPath();
                ctx.moveTo(ghost.x * TILE_SIZE + TILE_SIZE / 2, ghost.y * TILE_SIZE + TILE_SIZE / 2);
                ctx.arc(ghost.x * TILE_SIZE + TILE_SIZE / 2, ghost.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 2 * 0.9, Math.PI, 0, false);
                ctx.lineTo(ghost.x * TILE_SIZE + TILE_SIZE / 2 + TILE_SIZE / 2 * 0.9, ghost.y * TILE_SIZE + TILE_SIZE / 2 + TILE_SIZE / 2 * 0.9);
                ctx.lineTo(ghost.x * TILE_SIZE + TILE_SIZE / 2 + TILE_SIZE / 2 * 0.9 * 0.5, ghost.y * TILE_SIZE + TILE_SIZE / 2 + TILE_SIZE / 2 * 0.5);
                ctx.lineTo(ghost.x * TILE_SIZE + TILE_SIZE / 2, ghost.y * TILE_SIZE + TILE_SIZE / 2 + TILE_SIZE / 2 * 0.9);
                ctx.lineTo(ghost.x * TILE_SIZE + TILE_SIZE / 2 - TILE_SIZE / 2 * 0.9 * 0.5, ghost.y * TILE_SIZE + TILE_SIZE / 2 + TILE_SIZE / 2 * 0.5);
                ctx.lineTo(ghost.x * TILE_SIZE + TILE_SIZE / 2 - TILE_SIZE / 2 * 0.9, ghost.y * TILE_SIZE + TILE_SIZE / 2 + TILE_SIZE / 2 * 0.9);
                ctx.closePath();
                ctx.fill();
            });
        }

        function updateScore() {
            scoreValue.textContent = score;
        }

        function updateLives() {
            livesValue.textContent = lives;
        }

        function updateLevel() {
            levelValue.textContent = level;
        }

        function checkCollision(obj1, obj2) {
            const distance = Math.sqrt(Math.pow(obj1.x - obj2.x, 2) + Math.pow(obj1.y - obj2.y, 2));
            return distance < 1; 
        }

        function movePacman() {
            if (isRespawning) return;

            const currentTileX = Math.round(pacman.x);
            const currentTileY = Math.round(pacman.y);
            
            const isAligned = Math.abs(pacman.x - currentTileX) < 0.05 && Math.abs(pacman.y - currentTileY) < 0.05;

            if (isAligned && (intendedDx !== 0 || intendedDy !== 0)) {
                const nextIntendedX = currentTileX + intendedDx / PACMAN_SPEED;
                const nextIntendedY = currentTileY + intendedDy / PACMAN_SPEED;
                
                if (gameMaze[nextIntendedY] && gameMaze[nextIntendedY][nextIntendedX] !== 'W') {
                    pacman.dx = intendedDx;
                    pacman.dy = intendedDy;
                    intendedDx = 0;
                    intendedDy = 0;
                    pacman.x = currentTileX;
                    pacman.y = currentTileY;
                }
            }

            const newX = pacman.x + pacman.dx;
            const newY = pacman.y + pacman.dy;

            const nextTileX = Math.round(newX);
            const nextTileY = Math.round(newY);

            if (gameMaze[nextTileY] && gameMaze[nextTileY][nextTileX] === 'W') {
                pacman.dx = 0;
                pacman.dy = 0;
                pacman.x = currentTileX;
                pacman.y = currentTileY;
            } else {
                pacman.x = newX;
                pacman.y = newY;
            }
            
            if (pacman.x < 0) pacman.x = GRID_WIDTH - 1;
            if (pacman.x >= GRID_WIDTH) pacman.x = 0;
        }

        // Ghost random walk
        function moveGhosts() {
            ghosts.forEach(ghost => {
                const currentTileX = Math.round(ghost.x);
                const currentTileY = Math.round(ghost.y);
                
                if (Math.abs(ghost.x - currentTileX) < GHOST_SPEED && Math.abs(ghost.y - currentTileY) < GHOST_SPEED) {
                    const possibleMoves = [];
                    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

                    directions.forEach(dir => {
                        const checkX = currentTileX + dir[0];
                        const checkY = currentTileY + dir[1];
                        
                        if (gameMaze[checkY] && gameMaze[checkY][checkX] !== 'W') {
                            if (dir[0] !== -ghost.dx / GHOST_SPEED || dir[1] !== -ghost.dy / GHOST_SPEED) {
                                possibleMoves.push(dir);
                            }
                        }
                    });

                    if (possibleMoves.length > 0) {
                        const move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        ghost.dx = move[0] * GHOST_SPEED;
                        ghost.dy = move[1] * GHOST_SPEED;
                    } else {
                        ghost.dx *= -1;
                        ghost.dy *= -1;
                    }
                }
                
                ghost.x += ghost.dx;
                ghost.y += ghost.dy;
            });
        }

        function handleCollision() {
            if (isRespawning) return;
            ghosts.forEach(ghost => {
                if (checkCollision(pacman, ghost)) {
                    isRespawning = true;
                    respawnTimer = 1000;

                    pacman.dx = 0;
                    pacman.dy = 0;
                    intendedDx = 0;
                    intendedDy = 0;

                    if (ghost.scared) {
                        score += 500;
                        ghost.x = Math.floor(GRID_WIDTH / 2);
                        ghost.y = Math.floor(GRID_HEIGHT / 2);
                        ghost.scared = false;
                        ghost.released = false;
                        updateScore();
                    } else {
                        lives--;
                        updateLives();
                        if (lives <= 0) {
                            endGame();
                        } else {
                            resetPacmanAndGhosts();
                        }
                    }
                }
            });
        }

        function resetPacmanAndGhosts() {
            pacman.x = 1;
            pacman.y = 1;
            pacman.dx = 0;
            pacman.dy = 0;
            intendedDx = 0;
            intendedDy = 0;
            
            const ghostSpawnX = Math.floor(GRID_WIDTH / 2);
            const ghostSpawnY = Math.floor(GRID_HEIGHT / 2);

            ghosts.forEach((ghost, index) => {
                let foundSpot = false;
                let attempts = 0;
                while (!foundSpot && attempts < 100) {
                    const randX = Math.floor(Math.random() * GRID_WIDTH);
                    const randY = Math.floor(Math.random() * GRID_HEIGHT);
                    const isFarEnough = (Math.abs(randX - 1) + Math.abs(randY - 1) > 5);
                    if (gameMaze[randY] && gameMaze[randY][randX] !== 'W' && isFarEnough) {
                        ghost.x = randX;
                        ghost.y = randY;
                        foundSpot = true;
                    }
                    attempts++;
                }
                ghost.dx = 0;
                ghost.dy = 0;
                ghost.released = true;
            });
        }

        function saveScore() {
            scoreboard.push({
                nickname: nickname,
                level: level,
                score: score
            });
            scoreboard.sort((a, b) => b.score - a.score);
            if (scoreboard.length > 5) {
                scoreboard.pop();
            }
            renderScoreboard();
        }

        function renderScoreboard() {
            scoreboardList.innerHTML = '';
            scoreboard.forEach(entry => {
                const li = document.createElement('li');
                li.innerHTML = `<span>${entry.nickname}</span><span>레벨 ${entry.level}</span><span>${entry.score}점</span>`;
                scoreboardList.appendChild(li);
            });
        }

        function endGame() {
            isGameOver = true;
            gameRunning = false;
            finalScore.textContent = score;
            saveScore();
            gameOverScreen.classList.remove('hidden');
        }

        function gameLoop(timestamp) {
            if (!gameRunning) return;

            const deltaTime = timestamp - lastTimestamp;
            lastTimestamp = timestamp;

            if (isRespawning) {
                respawnTimer -= deltaTime;
                if (respawnTimer <= 0) {
                    isRespawning = false;
                    pacman.dx = intendedDx;
                    pacman.dy = intendedDy;
                }
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawMaze();
            drawPacman();
            drawGhosts();
            
            if (!isRespawning) {
                movePacman();
                moveGhosts();
            }
            handleCollision();

            const pacmanGridX = Math.round(pacman.x);
            const pacmanGridY = Math.round(pacman.y);
            if (gameMaze[pacmanGridY] && gameMaze[pacmanGridY][pacmanGridX] === '.') {
                gameMaze[pacmanGridY][pacmanGridX] = ' ';
                score += 10;
                dots--;
                updateScore();
            }

            if (dots <= 0) {
                nextLevel();
            }

            pacman.mouthOpen = Math.sin(timestamp / 100) > 0;

            if (!isGameOver) {
                requestAnimationFrame(gameLoop);
            }
        }

        document.addEventListener('keydown', (e) => {
            if (!gameRunning) return;

            switch (e.key) {
                case 'ArrowUp':
                    intendedDy = -PACMAN_SPEED;
                    pacman.angle = -Math.PI / 2;
                    intendedDx = 0;
                    break;
                case 'ArrowDown':
                    intendedDy = PACMAN_SPEED;
                    pacman.angle = Math.PI / 2;
                    intendedDx = 0;
                    break;
                case 'ArrowLeft':
                    intendedDx = -PACMAN_SPEED;
                    pacman.angle = Math.PI;
                    intendedDy = 0;
                    break;
                case 'ArrowRight':
                    intendedDx = PACMAN_SPEED;
                    pacman.angle = 0;
                    intendedDy = 0;
                    break;
            }
        });

        startButton.addEventListener('click', () => {
            const inputNickname = nicknameInput.value.trim();
            nickname = inputNickname === '' ? 'guest' : inputNickname;
            initGame();
            requestAnimationFrame(gameLoop);
        });

        guestButton.addEventListener('click', () => {
            nickname = 'guest';
            initGame();
            requestAnimationFrame(gameLoop);
        });

        restartButton.addEventListener('click', () => {
            startScreen.classList.remove('hidden');
            gameOverScreen.classList.add('hidden');
            canvas.style.display = 'none';
        });

        window.onload = () => {
            renderScoreboard();
        };
    </script>
</body>
</html>




